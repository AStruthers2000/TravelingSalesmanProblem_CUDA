
#include "AntColony.cuh"

#include <iostream>
#include <curand_kernel.h>

/********** Global memory **********/
int cities;

double* host_distances, *host_pheromones;
double* dev_distances, *dev_pheromones;

double* host_distancesHistory;
double* dev_distancesHistory;

int* dev_toursHistory, *dev_visitedHistory;

curandState* dev_curandStates;

/********** Main function **********/
/**
 * \brief The main entry point for the ACO algorithm
 *
 * Handles the allocation, initialization, running, and freeing of all memory throughout the simulation. This function
 * is passed an adjacency matrix that defines the problem we are trying to solve, as well as the problem size. This
 * function is responsible for all the kernel calls needed for ACO, and iterates the desired number of iterations,
 * performing memory management when necessary.
 * @param adj_mat The problem definition. A flattened 1D array that represents the problem instance. Can be symmetric or asymmetric
 * @param size The problem size, aka the number of cities
 * @return The best solution generated by any ant after the desired number of iterations
 */
double ACO_main(double *adj_mat, int size)
{
    cities = size;

    allocate_memory();
    initialize_values(adj_mat);

    //print_matrix(host_distances, "Distances");
    //print_matrix(host_pheromones, "Pheromones");

    time_t seed;
    time(&seed);

    //initializes cuRAND states. Currently, the device handles random number generation when needed. We could optimize this
    //by pre-generating many numbers that we pass to the device and use on the device when necessary. This could improve the runtime
    //efficiency, but for now this solution is sufficient
    setup_curand_states<<<GROUPS_OF_N_ANTS, THREADS_PER_BLOCK>>>(dev_curandStates, (unsigned long) seed);
    cudaDeviceSynchronize();


    const int matrix_blocks = static_cast<int>(floor((cities * cities) / THREADS_PER_BLOCK)) + 1;

    for(int iter = 0; iter < NUM_ITERATIONS; iter++)
    {
        //the first part of ACO is having each ant move and generate a single solution probabilistically
        move_ant<<<GROUPS_OF_N_ANTS, THREADS_PER_BLOCK>>>(dev_pheromones, dev_distances, dev_curandStates, dev_distancesHistory,
                                                          dev_toursHistory, dev_visitedHistory, cities);
        cudaDeviceSynchronize();

        //the following commented code is useful for logging the fitness each iteration. This clearly takes more time than
        //necessary when we don't care about the fitness each iteration, but can be useful for determining fitness behavior
//        auto host_dist = (double*)(malloc(NUM_ANTS * sizeof(double)));
//        cudaMemcpy(host_dist, dev_distancesHistory, NUM_ANTS * sizeof(double), cudaMemcpyDeviceToHost);
//        double sum = 0.0;
//        double min = std::numeric_limits<double>::max();
//        for(int i = 0; i < NUM_ANTS; i++)
//        {
//            sum += host_dist[i];
//            if(host_dist[i] < min)
//                min = host_dist[i];
//        }
//        double avg = sum / NUM_ANTS;
//        std::cout << "Average value on iter " << iter << ": " << avg << std::endl;
//        std::cout << "Minimum value on iter " << iter << ": " << min << std::endl;
//        free(host_dist);

        //the second part of ACO is to evaporate the pheromones uniformly. We do this by having 1 thread for each edge
        //in the pheromone matrix. This way we can write in parallel and update the matrix concurrently
        evaporate_pheromone<<<matrix_blocks, THREADS_PER_BLOCK>>>(dev_pheromones, cities);
        cudaDeviceSynchronize();

        //the last step in the standard ACO is to then update the pheromone matrix with the ants solutions. In this step
        //we have each ant be responsible for updating the edges that they traversed. This will cause a small data race
        //because multiple ants could walk the same edge and update simultaneously, but we handle this by using atomic operations
        update_pheromone<<<GROUPS_OF_N_ANTS, THREADS_PER_BLOCK>>>(dev_pheromones, dev_distancesHistory,
                                                                      dev_toursHistory, cities);
        cudaDeviceSynchronize();

        //we want to reset the histories of each ant after each iteration (except the last one) so that no false data for
        //tours or previous city visits persists for the next run
        if(iter < NUM_ITERATIONS - 1)
        {
            reset_histories<<<GROUPS_OF_N_ANTS, THREADS_PER_BLOCK>>>(dev_distancesHistory, dev_toursHistory,
                                                                     dev_visitedHistory, cities);
            cudaDeviceSynchronize();
        }
    }

    //we copy the array of ant distances to the host so that we can find the minimum distance, aka best solution
    auto host_dist = (double*)(malloc(NUM_ANTS * sizeof(double)));
    cudaMemcpy(host_dist, dev_distancesHistory, NUM_ANTS * sizeof(double), cudaMemcpyDeviceToHost);
    double min = std::numeric_limits<double>::max();
    for(int i = 0; i < NUM_ANTS; i++)
    {
        if(host_dist[i] < min)
            min = host_dist[i];
    }
    std::cout << "Minimum value: " << min << std::endl;
    free(host_dist);

    //free memory and reset the device so that next runs are completely independent
    free_memory();
    cudaDeviceReset();

    return min;
}


/********** Kernel calls **********/
/**
 * \brief Function that handles the probabilistic tour generation behavior each ant will have
 *
 * Each ant probabilistically generates a tour using roulette wheel selection for random city movement. The roulette wheel
 * is determined by the probability equation for ACO. Ants start at unique cities, ensuring that no edge is favored over
 * any other. The ants start at the city equal to the ant's unique ID mod the number of cities, so that we get an even distribution
 * of ants starting at each city. This ensures the solution space is appropriately explored.
 * @param matrix_pheromones Pheromone matrix to help guide the ants
 * @param matrix_distances Distance matrix provided for visible heuristic information
 * @param states cuRAND states used for generating random probabilities. This can be optimized to have pre-generated random numbers instead of generating them on the device during runtime
 * @param history_distances An array so that each ant can store its distance at the end of tour generation
 * @param history_tours An array of size num_ants * num_cities so that each ant can record its tour in order
 * @param history_visited An array of size num_ants * num_cities so that each ant can track the cities they've visited this iteration
 * @param num_cities The number of cities each and must visit
 */
__global__ void
move_ant(const double *matrix_pheromones, const double *matrix_distances, curandState *states,
         double *history_distances, int *history_tours, int *history_visited, int num_cities)
{
    //where the ant's history starts
    unsigned int ant_id = get_index();

    //we will get an even distribution of ants starting at the various cities
    //with roughly an even number of ants starting at each city
    int current_city = static_cast<int>(ant_id) % num_cities;
    history_visited[ant_id * num_cities + current_city] = 1;
    history_tours[ant_id * num_cities] = current_city;

    //printf("Thread %d:%d starts at city %d\n", blockIdx.x, threadIdx.x, current_city);

    //we will iterate n - 1 times, because we already know where we want to start
    //on each iteration, we will calculate the probabilities of visiting each city
    //that this ant hasn't visited yet, then use roulette wheel selection to visit
    //a city determined probabilistically. Once this loop completes, we need to also
    //add the distance travelled from the last visited city, back to the beginning
    //because a tour is only finished once we return to where we started
    for(int i = 1; i < num_cities; i++)
    {
        //we only care about accumulating probability for cities we have not visited
        //we want to compute:
        //\sum_{m\in allowed} \tau_{im}^\alpha \cdot \eta_{im}^\beta
        //where allowed is all cities we haven't visited yet
        double total_prob = 0.0;
        for(int next_city = 0; next_city < num_cities; next_city++)
        {
            //aka we have not yet visited this city
            if (history_visited[ant_id * num_cities + next_city] != 1)
            {
                int city_index = current_city * num_cities + next_city;
                double tau = matrix_pheromones[city_index];
                double eta = 1.0 / matrix_distances[city_index];
                total_prob += pow(tau, ALPHA) * pow(eta, BETA);
            }
        }

        //perform roulette wheel selection to select our next city
        double r = curand_uniform(&states[ant_id]) * total_prob;
        double accum_prob = 0.0;
        int selected_city = -1;

        //for each possible city, we want to compute:
        //\tau_{im}^\alpha \cdot \eta_{im}^\beta
        //so that we can calculate P_{ij} as this product divided by the sum calculated above
        int last_best = 0;
        for(int next_city = 0; next_city < num_cities; next_city++)
        {
            if(history_visited[ant_id * num_cities + next_city] != 1)
            {
                last_best = next_city;

                int city_index = current_city * num_cities + next_city;

                double tau = matrix_pheromones[city_index];
                double eta = 1.0 / matrix_distances[city_index];

                double prob = pow(tau, ALPHA) * pow(eta, BETA);
                //double prob = num / total_prob;
                accum_prob += prob;
                //printf("\tThread %d:%d tried to go to city %d, with a probability of %2.2f where accum prob = %2.2f\n", blockIdx.x, threadIdx.x, next_city, prob, accum_prob);

                if(accum_prob >= r)
                {
                    selected_city = next_city;
                    break;
                }
            }
        }

        //used for error checking just in case our indexing was incorrect
        if(selected_city == -1)
        {
            selected_city = last_best;
            printf("ERROR -1 || %d || accumProb %f || r %f\n", ant_id, accum_prob, r);
        }

        //printf("Thread %d:%d is now visiting city %d\n", blockIdx.x, threadIdx.x, selected_city);

        //now that we have selected a city using the probability equation
        //we want to actually move to that city.
        //We need to add this city to this ant's tour, add this city to this
        //ant's visited history, and add the distance from this move to this ant's
        //distance history
        history_tours[ant_id * num_cities + i] = selected_city;
        history_visited[ant_id * num_cities + selected_city] = 1;
        history_distances[ant_id] += matrix_distances[current_city * num_cities + selected_city];
        current_city = selected_city;
    }

    //we need to return to the starting city now
    //we go from the last visited city
    int from = history_tours[ant_id * num_cities + (num_cities - 1)];
    //to the first visited city
    int to = history_tours[ant_id * num_cities];
    history_distances[ant_id] += matrix_distances[from * num_cities + to];
}

/**
 * \brief Allows for uniform pheromone evaporation
 *
 * Uniformly evaporates each edge's pheromones based off of the constant #RHO
 * @param matrix_pheromones A pointer to the pheromone matrix to be evaporated
 * @param num_cities The number of cities, aka the dimension of the pheromone matrix
 */
__global__ void evaporate_pheromone(double *matrix_pheromones, int num_cities)
{
    unsigned int index = get_index();
    if(index < num_cities * num_cities)
    {
        matrix_pheromones[index] *= (1.0 - RHO);

        //UNUSED, NOT NECESSARY:
        //never let the pheromone trail get to 0 or less, because we want to encourage exploration
        //if the pheromone trail was = 0, no ant would ever walk on this route again
        //if the pheromone trail was < 0, that doesn't make sense. ants don't produce ANTi-pheromone (ha, ant pun, thanks Abbi)

        /*
        if(matrix_pheromones[index] <= 0.0)
        {
            matrix_pheromones[index] = 1.0 / num_cities;
        }
         */
    }
}

/**
 * \brief Updating the pheromones according to the standard constant pheromone deposit method
 *
 * We use the standard constant pheromone deposit method for simplicity, but the AS-LBT method of pheromone updating
 * shows substantially better results. This is an area of future work we want to consider to improve this algorithm
 * @param matrix_pheromones A pointer to the pheromone matrix to be updated
 * @param history_distances Each ant's solution found on this iteration
 * @param history_tours Each ant's tour for this iteration
 * @param num_cities The number of cities each ant visited
 */
__global__ void update_pheromone(double* matrix_pheromones, const double* history_distances, const int* history_tours, int num_cities)
{
    unsigned int ant_id = get_index();

    //assert(history_distances[ant_id] > 0);
    //constant pheromone deposit method
    double pheromone_delta = Q / (history_distances[ant_id] + 0.001);

    //iterate through each edge traveled by an ant
    for(int i = 0; i < num_cities; i++)
    {
        int from, to;

        //if we aren't at the end of the tour yet
        if(i < num_cities - 1)
        {
            //we want to add the pheromone delta to the edge {v_i, v_{i+1}}
            from = history_tours[ant_id * num_cities + i];
            to = history_tours[ant_id * num_cities + i + 1];
        }
        //if we are at the end of the tour
        else
        {
            //we want to add the pheromone delta to the edge {v_{n-1}, v_0}
            //this is because we want to end the full tour where we started (v_0)
            from = history_tours[ant_id * num_cities + i];
            to = history_tours[ant_id * num_cities];
        }

        //we update the entry at city_index with the pheromone delta
        //because we are using the pheromone matrix to represent the weight
        //of traveling where start = from and end = to. Since we collapsed the
        //matrix into a 1d array, the edge between vertices {from, to} is stored
        //at the ant_id from * n + to, where n = num_cities. This is a standard way
        //of using a 1d array as a matrix
        int city_index = from * num_cities + to;

        //printf("Ant %d went from %d to %d\n", ant_id, from, to);

        //this kernel runs once for each ant, so that each ant's matrix_pheromones
        //can be calculated in parallel, but we must use atomic operations
        //as to not overwrite our update when another ant is currently updating
        auto a = &matrix_pheromones[city_index];
        atomicAdd(a, pheromone_delta);
    }
}

/**
 * \brief A function used to reset the histories of each ant to prevent confusion in future iterations
 * @param history_distances The distance history of each ant
 * @param history_tours The tour history of each ant
 * @param history_visited The visited cities of each ant (should be an array of all 1s)
 * @param num_cities The size of the problem
 */
__global__ void reset_histories(double *history_distances, int *history_tours, int *history_visited, int num_cities)
{
    unsigned int ant_id = get_index();
    history_distances[ant_id] = 0.0;

    for(int i = 0; i < num_cities; i++)
    {
        history_tours[ant_id * num_cities + i] = 0;
        history_visited[ant_id * num_cities + i] = 0;
    }
}


/********** Memory allocation and deallocation **********/
/**
 * \brief A function used to allocate all host and device memory in one organized location
 */
void allocate_memory()
{
    host_distances = (double*)(malloc(cities * cities * sizeof(double)));
    host_pheromones = (double*)(malloc(cities * cities * sizeof(double)));
    host_distancesHistory = (double*)(malloc(NUM_ANTS * sizeof(double)));

    cudaMalloc(&dev_distances, cities * cities * sizeof(double));
    cudaMalloc(&dev_pheromones, cities * cities * sizeof(double));
    cudaMalloc(&dev_distancesHistory, NUM_ANTS * sizeof(double));
    cudaMalloc(&dev_toursHistory, NUM_ANTS * cities * sizeof(int));
    cudaMalloc(&dev_visitedHistory, NUM_ANTS * cities * sizeof(int));
    cudaMalloc(&dev_curandStates, NUM_ANTS * sizeof(curandState));
}

/**
 * \brief A function used to initialize all host memory and copy over initial states to the device when necessary
 * @param adj_mat The adjacency matrix for this problem run
 */
void initialize_values(double *adj_mat)
{
    memcpy(host_distances, adj_mat, cities * cities * sizeof(double));
    //print_matrix(host_distances, "Distances:");

    //initialize pheromone matrix to INIT_PHEROMONE_LEVEL as an arbitrary starting level
    for(int i = 0; i < cities; i++)
    {
        for(int j = 0; j < cities; j++)
        {
            int index = i * cities + j;
            if (i != j)
            {
                host_pheromones[index] = INIT_PHEROMONE_LEVEL;
            }
            else
            {
                host_pheromones[index] = 0.0;
            }
        }
    }

    cudaMemcpy(dev_distances, host_distances, cities * cities * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(dev_pheromones, host_pheromones, cities * cities * sizeof(double), cudaMemcpyHostToDevice);
}

/**
 * \brief A function used to free all host and device memory at the end of runtime execution
 */
void free_memory()
{
    free(host_distances);
    free(host_pheromones);
    free(host_distancesHistory);

    cudaFree(dev_distances);
    cudaFree(dev_pheromones);
    cudaFree(dev_distancesHistory);
    cudaFree(dev_toursHistory);
    cudaFree(dev_visitedHistory);
    cudaFree(dev_curandStates);
}


/********** Helper functions **********/
/**
 * \brief A helper function to calculate the unique thread ID
 * @return The unique ID of this thread
 */
__device__ unsigned int get_index()
{
    return blockDim.x * blockIdx.x + threadIdx.x;
}

/**
 * \brief A helper function to initialize cuRAND states with a random seed
 * @param dev_states A pointer to the cuRAND states on the device needing initialization
 * @param seed The randomly determined seed
 */
__global__ void setup_curand_states(curandState* dev_states, unsigned long seed)
{
    unsigned int index = get_index();
    if(index < NUM_ANTS)
    {
        curand_init(seed, index, 0, &dev_states[index]);
    }
}

/**
 * \brief A simple helper function to print a matrix, useful for debugging
 * @param matrix Matrix to be printed
 * @param msg Message to be included along with the printing of the matrix
 */
[[maybe_unused]] void print_matrix(const double* matrix, const char* msg)
{
    printf("%s: \n", msg);
    for(int i = 0; i < cities; i++)
    {
        for(int j = 0; j < cities; j++)
        {
            printf("%2.2f\t", matrix[i * cities + j]);
        }
        printf("\n");
    }
}

